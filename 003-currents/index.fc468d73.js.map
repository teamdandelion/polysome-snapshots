{"mappings":"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","sources":["<anon>","src/polysome.ts","p5.js","src/world.ts","src/mote.ts","src/collisions.ts","src/flowField.ts","src/safeMath.ts","src/spec.ts","src/randomSeed.ts","src/safeRandom.ts","src/renderContext.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $ab4097e3648e46bf$exports = {};\n$ab4097e3648e46bf$exports = p5;\n\n\n\n\nclass $5fee48862b0a2a9b$export$c63751cf8691a0b8 {\n    constructor(pos, radius){\n        this.nCollisions = 0;\n        this.pos = pos;\n        this.vCollide = new (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector(0, 0);\n        this.radius = radius;\n    }\n    resetCollisions() {\n        this.vCollide = new (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector(0, 0);\n        this.nCollisions = 0;\n    }\n}\n\n\nfunction $853c9283513b3b8b$var$checkCollide(p1, p2, r) {\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    return dx * dx + dy * dy < r * r;\n}\nfunction $853c9283513b3b8b$export$d237b9963f3ebafd(motes, extraRadius, sectorSize, worldDim) {\n    if (sectorSize <= 0 || worldDim <= 0 || sectorSize > worldDim || worldDim % sectorSize !== 0) throw new Error(\"invalid sector configuration\");\n    const results = [];\n    const gridDimension = worldDim / sectorSize;\n    const sectors = new Array(gridDimension * gridDimension).fill(null).map(()=>[]);\n    motes.forEach((mote)=>{\n        if (mote.radius < 0 || !Number.isFinite(mote.radius)) throw new Error(\"Mote has invalid radius\");\n        const { pos: pos, radius: radius } = mote;\n        if (pos.x >= worldDim || pos.x < 0 || pos.y >= worldDim || pos.y < 0) throw new Error(\"Mote out of bounds\");\n        const i = Math.floor(mote.pos.x / sectorSize);\n        const j = Math.floor(mote.pos.y / sectorSize);\n        sectors[j * gridDimension + i].push(mote);\n    });\n    sectors.forEach((sector, index)=>{\n        let adjacentIndices = [];\n        if (gridDimension === 1) adjacentIndices = [];\n        else if (gridDimension === 2) adjacentIndices = [\n            index - gridDimension - 1,\n            index - gridDimension,\n            index - 1\n        ];\n        else adjacentIndices = [\n            index - gridDimension - 1,\n            index - gridDimension,\n            index - gridDimension + 1,\n            index - 1\n        ];\n        for(let i = 0; i < sector.length; i++){\n            const mote1 = sector[i];\n            // Check for collisions within the current sector\n            for(let j = i + 1; j < sector.length; j++){\n                const mote2 = sector[j];\n                if ($853c9283513b3b8b$var$checkCollide(mote1.pos, mote2.pos, mote1.radius + mote2.radius + extraRadius)) results.push([\n                    mote1,\n                    mote2\n                ]);\n            }\n            // Check for collisions within adjacent sectors\n            adjacentIndices.forEach((adjacentIndex)=>{\n                if (adjacentIndex >= 0 && adjacentIndex < sectors.length) {\n                    const adjacentSector = sectors[adjacentIndex];\n                    for(let j = 0; j < adjacentSector.length; j++){\n                        const mote2 = adjacentSector[j];\n                        if ($853c9283513b3b8b$var$checkCollide(mote1.pos, mote2.pos, mote1.radius + mote2.radius + extraRadius)) results.push([\n                            mote1,\n                            mote2\n                        ]);\n                    }\n                }\n            });\n        }\n    });\n    return results;\n}\n\n\nclass $3aec07e3cb255787$export$812cd9544993280d {\n    constructor(spec, rng, flowField){\n        this.spec = spec;\n        this.motes = [];\n        this.rng = rng;\n        this.flowField = flowField;\n        while(this.motes.length < this.spec.numMotes)this.addMote();\n    }\n    randomPos() {\n        const spec = this.spec;\n        return new (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector(this.rng.uniform(0, spec.xDim), this.rng.uniform(0, spec.yDim));\n    }\n    inBounds(pos) {\n        return pos.x >= 0 && pos.x <= this.spec.xDim && pos.y >= 0 && pos.y <= this.spec.yDim;\n    }\n    // Adds a mote to the world\n    addMote() {\n        const mote = new (0, $5fee48862b0a2a9b$export$c63751cf8691a0b8)(this.randomPos(), this.spec.moteRadius);\n        this.motes.push(mote);\n    }\n    // Steps through one time unit in the simulation\n    step() {\n        while(this.motes.length < this.spec.numMotes)this.addMote();\n        const ff = this.flowField;\n        this.motes.forEach((mote)=>mote.resetCollisions());\n        const collidingMotes = (0, $853c9283513b3b8b$export$d237b9963f3ebafd)(this.motes, this.spec.moteInfluenceRadius, this.spec.sectorSize, Math.max(this.spec.xDim, this.spec.yDim));\n        for (const [mote1, mote2] of collidingMotes){\n            const v = (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector.sub(mote1.pos, mote2.pos);\n            const d = v.mag();\n            const boundaryDistance = d - mote1.radius - mote2.radius;\n            let forceFactor;\n            if (boundaryDistance < 0) forceFactor = 0.2;\n            else forceFactor = 0.2 * (this.spec.moteInfluenceRadius - boundaryDistance) / this.spec.moteInfluenceRadius;\n            v.setMag(forceFactor);\n            mote1.vCollide.add(v);\n            mote2.vCollide.sub(v);\n            mote1.nCollisions++;\n            mote2.nCollisions++;\n        }\n        this.motes.forEach((mote)=>{\n            const vel = ff.flow(mote.pos);\n            mote.pos.add(vel);\n            mote.pos.add(mote.vCollide);\n        });\n        this.motes = this.motes.filter((mote)=>this.inBounds(mote.pos));\n    }\n    render(rc) {\n        rc.background(240, 100, 10);\n        rc.strokeWeight(2);\n        rc.noFill();\n        this.motes.forEach((mote)=>{\n            let hue = 30 + mote.nCollisions * 4;\n            rc.stroke(hue, 100, 40 + mote.nCollisions, 80);\n            rc.circle(mote.pos.x, mote.pos.y, mote.radius);\n        });\n    }\n}\n\n\n\n// Helpful math functions, adapted from safeMath.js in qql-art/frontend\nfunction $0e2c58cfdfdc3132$export$18c7bea995a110f(v) {\n    return Math.PI * v;\n}\nfunction $0e2c58cfdfdc3132$export$842a2cf37af977e1(n, m) {\n    return (n % m + m) % m;\n}\nfunction $0e2c58cfdfdc3132$export$51a0620f7a28532b(value, step) {\n    return Math.round(value / step) * step;\n}\nfunction $0e2c58cfdfdc3132$export$e0b576e7a74416cd(value, min = null, max = null) {\n    value = max !== null ? Math.min(value, max) : value;\n    value = min !== null ? Math.max(value, min) : value;\n    return value;\n}\nfunction $0e2c58cfdfdc3132$export$bd2782c820638828(value, oldMin, oldMax, newMin, newMax) {\n    const clipped = $0e2c58cfdfdc3132$export$e0b576e7a74416cd(value, oldMin, oldMax);\n    const oldSpread = oldMax - oldMin;\n    const newSpread = newMax - newMin;\n    return newMin + (clipped - oldMin) * (newSpread / oldSpread);\n}\nfunction $0e2c58cfdfdc3132$export$1da80b13a4f0c868(start, end, t) {\n    return start + (end - start) * t;\n}\nfunction $0e2c58cfdfdc3132$export$cc6710ee5f037d57(...args) {\n    return args.reduce((lhs, rhs)=>lhs + rhs, 0) / args.length;\n}\nfunction $0e2c58cfdfdc3132$export$eba8049fb5020b81(value, maxIterations = 1000, epsilon = 1e-14, target = 1e-7) {\n    if (value < 0) throw new Error(\"Value must be non-negative.\");\n    let guess = value;\n    for(let index = 0; index < maxIterations; index++){\n        const error = guess * guess - value;\n        if (Math.abs(error) <= target) return guess;\n        const divisor = 2 * guess;\n        if (divisor <= epsilon) return guess;\n        guess -= error / divisor;\n    }\n    return guess;\n}\nfunction $0e2c58cfdfdc3132$export$6c4a311cc157c764(x1, y1, x2, y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return $0e2c58cfdfdc3132$export$eba8049fb5020b81(dx * dx + dy * dy);\n}\nfunction $0e2c58cfdfdc3132$export$b8b770ee6a0d9760(y, x) {\n    const ax = Math.abs(x);\n    const ay = Math.abs(y);\n    const mx = Math.max(ay, ax);\n    const mn = Math.min(ay, ax);\n    const a = mn / mx;\n    /* Minimax polynomial approximation to atan(a) on [0,1] */ const s = a * a;\n    const c = s * a;\n    const q = s * s;\n    let r = 0.024840285 * q + 0.18681418;\n    let t = -0.094097948 * q - 0.33213072;\n    r = r * s + t;\n    r = r * c + a;\n    /* Map to full circle */ if (ay > ax) r = 1.57079637 - r;\n    if (x < 0) r = 3.14159274 - r;\n    if (y < 0) r = -r;\n    return r;\n}\n// Build an interpolation-based lookup function from a given table.\n// The function is assumed period, so given values outside the range will wrap.\nfunction $0e2c58cfdfdc3132$var$buildInterpolator(table, min, max) {\n    return (value)=>{\n        // Coerce value to [min, max) assuming periodicity.\n        value = $0e2c58cfdfdc3132$export$842a2cf37af977e1(value - min, max - min) + min;\n        const rescaled = $0e2c58cfdfdc3132$export$bd2782c820638828(value, min, max, 0, table.length - 1);\n        const index = Math.floor(rescaled); // This is within [0, table.length - 1).\n        const fraction = rescaled - index; // This is within [0, 1).\n        // Function evaluated at value is within [start, end) based on index.\n        const start = table[index];\n        const end = table[index + 1];\n        // Interpolate within [start, end) using fractional part.\n        return $0e2c58cfdfdc3132$export$1da80b13a4f0c868(start, end, fraction);\n    };\n}\nconst $0e2c58cfdfdc3132$var$cosTable = [\n    1.0,\n    0.99179,\n    0.96729,\n    0.92692,\n    0.87132,\n    0.80141,\n    0.71835,\n    0.62349,\n    0.51839,\n    0.40478,\n    0.28453,\n    0.1596,\n    0.03205,\n    -0.09602,\n    -0.22252,\n    -0.34537,\n    -0.46254,\n    -0.57212,\n    -0.6723,\n    -0.76145,\n    -0.83809,\n    -0.90097,\n    -0.94906,\n    -0.98156,\n    -0.99795,\n    -0.99795,\n    -0.98156,\n    -0.94906,\n    -0.90097,\n    -0.83809,\n    -0.76145,\n    -0.6723,\n    -0.57212,\n    -0.46254,\n    -0.34537,\n    -0.22252,\n    -0.09602,\n    0.03205,\n    0.1596,\n    0.28453,\n    0.40478,\n    0.51839,\n    0.62349,\n    0.71835,\n    0.80141,\n    0.87132,\n    0.92692,\n    0.96729,\n    0.99179,\n    1.0\n];\nconst $0e2c58cfdfdc3132$export$50d414a77b60d802 = $0e2c58cfdfdc3132$var$buildInterpolator($0e2c58cfdfdc3132$var$cosTable, 0, 2 * Math.PI);\nconst $0e2c58cfdfdc3132$var$sinTable = [\n    0.0,\n    0.12788,\n    0.25365,\n    0.37527,\n    0.49072,\n    0.59811,\n    0.69568,\n    0.78183,\n    0.85514,\n    0.91441,\n    0.95867,\n    0.98718,\n    0.99949,\n    0.99538,\n    0.97493,\n    0.93847,\n    0.8866,\n    0.82017,\n    0.74028,\n    0.64823,\n    0.54553,\n    0.43388,\n    0.31511,\n    0.19116,\n    0.06407,\n    -0.06407,\n    -0.19116,\n    -0.31511,\n    -0.43388,\n    -0.54553,\n    -0.64823,\n    -0.74028,\n    -0.82017,\n    -0.8866,\n    -0.93847,\n    -0.97493,\n    -0.99538,\n    -0.99949,\n    -0.98718,\n    -0.95867,\n    -0.91441,\n    -0.85514,\n    -0.78183,\n    -0.69568,\n    -0.59811,\n    -0.49072,\n    -0.37527,\n    -0.25365,\n    -0.12788,\n    -0\n];\nconst $0e2c58cfdfdc3132$export$5de3937cb4b592ed = $0e2c58cfdfdc3132$var$buildInterpolator($0e2c58cfdfdc3132$var$sinTable, 0, 2 * Math.PI);\nfunction $0e2c58cfdfdc3132$export$944b09d2ad10b378(x1, y1, x2, y2) {\n    const a = $0e2c58cfdfdc3132$export$b8b770ee6a0d9760(y2 - y1, x2 - x1);\n    return $0e2c58cfdfdc3132$export$842a2cf37af977e1(a, $0e2c58cfdfdc3132$export$18c7bea995a110f(2.0));\n}\nfunction $0e2c58cfdfdc3132$export$d6d6f3cc49a6d900(x1, y1, x2, y2) {\n    const dx = Math.abs(x1 - x2);\n    const dy = Math.abs(y1 - y2);\n    const min = Math.min(dx, dy);\n    const max = Math.max(dx, dy);\n    const alpha = 1007 / 1110;\n    const beta = 441 / 1110;\n    return alpha * max + beta * min;\n}\nfunction $0e2c58cfdfdc3132$export$2d1a743c6fb30728(x1, y1, x2, y2) {\n    const dx = Math.abs(x1 - x2);\n    const dy = Math.abs(y1 - y2);\n    const min = Math.min(dx, dy);\n    const max = Math.max(dx, dy);\n    const beta = 441 / 1024;\n    return max + beta * min;\n}\nfunction $0e2c58cfdfdc3132$export$4db2b6380409b372(x, y, theta, magnitude) {\n    return [\n        x + magnitude * $0e2c58cfdfdc3132$export$50d414a77b60d802(theta),\n        y + magnitude * $0e2c58cfdfdc3132$export$5de3937cb4b592ed(theta)\n    ];\n}\n\n\nfunction $3e4f23251aebc465$export$15b688b761fa49c2(r, spec) {\n    const { numDisturbances: numDisturbances, thetaVariance: thetaVariance, defaultTheta: defaultTheta } = spec;\n    const disturbances = [];\n    for(let i = 0; i < numDisturbances; i++){\n        const disturbanceX = r.uniform(0, spec.xDim);\n        const disturbanceY = r.uniform(0, spec.yDim);\n        const disturbanceTheta = r.gauss(0, thetaVariance);\n        const disturbanceRadius = Math.abs(r.gauss(spec.disturbanceRadiusMean, spec.disturbanceRadiusVariance));\n        disturbances.push({\n            pos: new (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector(disturbanceX, disturbanceY),\n            theta: disturbanceTheta,\n            radius: disturbanceRadius\n        });\n    }\n    return {\n        defaultTheta: defaultTheta,\n        disturbances: disturbances\n    };\n}\nclass $3e4f23251aebc465$export$b28d348bb9299663 {\n    constructor(spec){\n        // Hack - Flow field still thinks its a 1000x1000 grid\n        this.xMin = 0;\n        this.xMax = 1000;\n        this.yMin = 0;\n        this.yMax = 1000;\n        this.spacing = 10;\n        const iMax = (this.xMax - this.xMin) / this.spacing;\n        const jMax = (this.yMax - this.yMin) / this.spacing;\n        this.fieldPoints = Array.from({\n            length: iMax\n        }, ()=>Array(jMax).fill(spec.defaultTheta));\n        for (const { pos: pos, theta: theta, radius: radius } of spec.disturbances){\n            const minX = pos.x - radius;\n            const maxX = pos.x + radius;\n            const minY = pos.y - radius;\n            const maxY = pos.y + radius;\n            const minI = Math.max(0, Math.floor(minX / this.spacing));\n            const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n            const minJ = Math.max(0, Math.floor(minY / this.spacing));\n            const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n            for(let i = minI; i < maxI; i++){\n                const x = this.spacing * i;\n                for(let j = minJ; j < maxJ; j++){\n                    const y = this.spacing * j;\n                    const d = (0, $0e2c58cfdfdc3132$export$6c4a311cc157c764)(pos.x, pos.y, x, y);\n                    const thetaAdjust = (0, $0e2c58cfdfdc3132$export$bd2782c820638828)(d, 0, radius, theta, 0);\n                    this.fieldPoints[i][j] += thetaAdjust;\n                }\n            }\n        }\n    }\n    flow(pos) {\n        const i = Math.floor(pos.x / this.spacing);\n        const j = Math.floor(pos.y / this.spacing);\n        const theta = this.fieldPoints[i][j];\n        return (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports))).Vector.fromAngle(theta);\n    }\n}\n\n\nclass $791c32fb268f4933$export$6298b650a59e6ea5 {\n    constructor(){\n        this.numMotes = 6000;\n        // Dimensions overwritten at p5 setup time,\n        // one will get reduced to match window ratio\n        this.xDim = 1000;\n        this.yDim = 1000;\n        this.moteRadius = 8;\n        this.moteInfluenceRadius = 8;\n        this.moteRenderScaling = 0.3;\n        this.sectorSize = 40;\n        // Flow field settings\n        this.numDisturbances = 30;\n        this.thetaVariance = 3.14;\n        this.defaultTheta = 0;\n        this.disturbanceRadiusMean = 100;\n        this.disturbanceRadiusVariance = 200;\n    }\n}\n\n\n// picks a uniformly random `bytes32` using JS Math.random state\n// (i.e., not itself seeded by `safe-random.js`)\nfunction $1751a11947656e80$export$2e2bcd8739ae039() {\n    let nibbles = Array(64).fill(0).map(()=>Math.floor(Math.random() * 16).toString(16));\n    return \"0x\" + nibbles.join(\"\");\n}\n\n\n\n// Note that the index order [0, 1, 2, 3] is little-endian\nconst $fc2b56482f704487$var$eps = Math.pow(2, -32), $fc2b56482f704487$var$m0 = 0x7f2d, $fc2b56482f704487$var$m1 = 0x4c95, $fc2b56482f704487$var$m2 = 0xf42d, $fc2b56482f704487$var$m3 = 0x5851, $fc2b56482f704487$var$a0 = 0x814f, $fc2b56482f704487$var$a1 = 0xf767, $fc2b56482f704487$var$a2 = 0x7b7e, $fc2b56482f704487$var$a3 = 0x1405; // 1442695040888963407\nfunction $fc2b56482f704487$export$7c1be48efc5e4b3b(hash /*: bytes32 */ ) /*: Rng */ {\n    const rng = new $fc2b56482f704487$export$b15cd8f5723f9e05();\n    rng.setSeed(hash);\n    return rng;\n}\nfunction $fc2b56482f704487$export$49af3cf86fe080fb() /*: Rng */ {\n    return $fc2b56482f704487$export$7c1be48efc5e4b3b((0, $1751a11947656e80$export$2e2bcd8739ae039)());\n}\nclass $fc2b56482f704487$export$b15cd8f5723f9e05 {\n    constructor(){\n        this._state = new Uint16Array(4);\n        this._dv = new DataView(this._state.buffer);\n        this._nG = null; // nextGaussian\n        this._hNG = false; // hasNextGaussian\n    }\n    // sets the seed to a tokenData hash string \"0x...\"\n    setSeed(hash) {\n        this._hNG = false;\n        this._nG = null;\n        const nBytes = ~~((hash.length - 2) / 2);\n        const bytes = [];\n        for(let j = 0; j < nBytes; j++){\n            const e0 = 2 + 2 * j;\n            bytes.push(parseInt(hash.slice(e0, e0 + 2), 16));\n        }\n        // to keep it simple, we just use 32bit murmur2 with two different seeds\n        const seed_a = 1690382925;\n        const seed_b = 72970470;\n        const lower = $fc2b56482f704487$var$hash32(bytes, seed_a);\n        const upper = $fc2b56482f704487$var$hash32(bytes, seed_b);\n        this._dv.setUint32(0, lower);\n        this._dv.setUint32(4, upper);\n    }\n    // random value between 0..1\n    rnd() {\n        const state = this._state;\n        // Advance internal state\n        const s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3], new0 = $fc2b56482f704487$var$a0 + $fc2b56482f704487$var$m0 * s0 | 0, new1 = $fc2b56482f704487$var$a1 + $fc2b56482f704487$var$m0 * s1 + ($fc2b56482f704487$var$m1 * s0 + (new0 >>> 16)) | 0, new2 = $fc2b56482f704487$var$a2 + $fc2b56482f704487$var$m0 * s2 + $fc2b56482f704487$var$m1 * s1 + ($fc2b56482f704487$var$m2 * s0 + (new1 >>> 16)) | 0, new3 = $fc2b56482f704487$var$a3 + $fc2b56482f704487$var$m0 * s3 + ($fc2b56482f704487$var$m1 * s2 + $fc2b56482f704487$var$m2 * s1) + ($fc2b56482f704487$var$m3 * s0 + (new2 >>> 16));\n        state[0] = new0, state[1] = new1, state[2] = new2;\n        state[3] = new3;\n        // Calculate output function (XSH RR), uses old state\n        const xorshifted = (s3 << 21) + ((s3 >> 2 ^ s2) << 5) + ((s2 >> 2 ^ s1) >> 11), out_int32 = xorshifted >>> (s3 >> 11) | xorshifted << (-(s3 >> 11) & 31);\n        return $fc2b56482f704487$var$eps * (out_int32 >>> 0);\n    }\n    // random value between min (inclusive) and max (exclusive)\n    uniform(min = 1, max = null) {\n        if (max === null) [min, max] = [\n            0,\n            min\n        ];\n        return this.rnd() * (max - min) + min;\n    }\n    // random gaussian distribution\n    gauss(mean = 0, variance = 1) {\n        // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/Random.java#L496\n        if (this._hNG) {\n            this._hNG = false;\n            var result = this._nG;\n            this._nG = null;\n            return mean + variance * result;\n        } else {\n            var v1 = 0;\n            var v2 = 0;\n            var s = 0;\n            do {\n                v1 = this.rnd() * 2 - 1; // between -1 and 1\n                v2 = this.rnd() * 2 - 1; // between -1 and 1\n                s = v1 * v1 + v2 * v2;\n            }while (s >= 1 || s === 0);\n            var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n            this._nG = v2 * multiplier;\n            this._hNG = true;\n            return mean + variance * (v1 * multiplier);\n        }\n    }\n    odds(p) {\n        return this.uniform() <= p;\n    }\n    choice(items) {\n        return items[Math.floor(this.uniform(0, items.length))];\n    }\n    weightedChoice(items) {\n        const sumWeight = items.map(([, weight])=>weight).reduce((lhs, rhs)=>lhs + rhs, 0);\n        const bisection = sumWeight * this.uniform();\n        let cumWeight = 0;\n        for(let index = 0; index < items.length; index++){\n            const [value, weight] = items[index];\n            cumWeight += weight;\n            if (cumWeight >= bisection) return value;\n        }\n        const [lastValue] = items[items.length - 1];\n        return lastValue;\n    }\n    // alias for weightedChoice\n    wc(items) {\n        return this.weightedChoice(items);\n    }\n    // a version of shuffle that safely uses our PRNG\n    shuffle(items) {\n        const joined = items.map((item)=>[\n                this.uniform(0.0, 1.0),\n                item\n            ]);\n        joined.sort((a, b)=>{\n            return a[0] < b[0] ? -1 : 1;\n        });\n        return joined.map(([, item])=>item);\n    }\n    // returns a copy of the array that has been \"winnowed\" down to contain at most `num`\n    // entries, while preserving the original order\n    winnow(input, num) {\n        const items = input.slice();\n        while(items.length > num){\n            const index = Math.floor(this.rnd() * items.length);\n            items.splice(index, 1);\n        }\n        return items;\n    }\n}\n// internally gets a 32-bit from tokenData hash bytes\nfunction $fc2b56482f704487$var$hash32(bytes, seed = 0) {\n    // murmur2 32bit\n    // https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\n    const K = 16;\n    const mask = 65535;\n    const maskByte = 0xff;\n    var m = 0x5bd1e995;\n    var l = bytes.length, h = seed ^ l, i = 0, k;\n    while(l >= 4){\n        k = bytes[i] & maskByte | (bytes[++i] & maskByte) << 8 | (bytes[++i] & maskByte) << 16 | (bytes[++i] & maskByte) << 24;\n        k = (k & mask) * m + (((k >>> K) * m & mask) << K);\n        k ^= k >>> 24;\n        k = (k & mask) * m + (((k >>> K) * m & mask) << K);\n        h = (h & mask) * m + (((h >>> K) * m & mask) << K) ^ k;\n        l -= 4;\n        ++i;\n    }\n    /* eslint-disable no-fallthrough */ switch(l){\n        case 3:\n            h ^= (bytes[i + 2] & maskByte) << K;\n        case 2:\n            h ^= (bytes[i + 1] & maskByte) << 8;\n        case 1:\n            h ^= bytes[i] & maskByte;\n            h = (h & mask) * m + (((h >>> K) * m & mask) << K);\n    }\n    /* eslint-enable no-fallthrough */ h ^= h >>> 13;\n    h = (h & mask) * m + (((h >>> K) * m & mask) << K);\n    h ^= h >>> 15;\n    return h >>> 0;\n}\n\n\nclass $f9aa35ed4b7c36bf$export$21d659604859c277 {\n    constructor(p5, spec, zoom){\n        this.p5 = p5;\n        this.spec = spec;\n        this.r = p5.windowWidth / spec.xDim;\n        this.zoom = zoom;\n        this.zoomX = spec.xDim / 2;\n        this.zoomY = spec.yDim / 2;\n        p5.pixelDensity(1);\n        p5.colorMode(p5.HSB, 360, 100, 100, 100);\n        this.c = p5.createCanvas(p5.windowWidth, p5.windowHeight);\n    }\n    background(h, s, b) {\n        this.p5.background(h, s, b);\n    }\n    stroke(h, s, b, a) {\n        this.p5.stroke(h, s, b, a);\n    }\n    noStroke() {\n        this.p5.noStroke();\n    }\n    circle(x, y, r) {\n        const px = (x - this.zoomX) * this.zoom * this.r + this.p5.windowWidth / 2;\n        const py = (y - this.zoomY) * this.zoom * this.r + this.p5.windowHeight / 2;\n        // underlying api uses diameter not radius, converted here.\n        this.p5.circle(px, py, 2 * r * this.r * this.zoom * this.spec.moteRenderScaling);\n    }\n    noFill() {\n        this.p5.noFill();\n    }\n    strokeWeight(w) {\n        this.p5.strokeWeight(w);\n    }\n}\n\n\nfunction $28c67c486a7b1e76$var$sketch(p5) {\n    let R /*: Rng */ ;\n    let rc;\n    let spec;\n    let world;\n    const worldDim = 1000;\n    p5.setup = ()=>{\n        let seed = (0, $1751a11947656e80$export$2e2bcd8739ae039)();\n        console.log(`seed: ${seed}`);\n        const rng = (0, $fc2b56482f704487$export$7c1be48efc5e4b3b)(seed);\n        const spec = new (0, $791c32fb268f4933$export$6298b650a59e6ea5)();\n        const wh = p5.windowHeight;\n        const ww = p5.windowWidth;\n        if (ww > wh) spec.yDim = spec.xDim * (wh / ww);\n        else spec.xDim = spec.yDim * (ww / wh);\n        const ff = new (0, $3e4f23251aebc465$export$b28d348bb9299663)((0, $3e4f23251aebc465$export$15b688b761fa49c2)(rng, spec));\n        const zoomLevel = 1.1;\n        rc = new (0, $f9aa35ed4b7c36bf$export$21d659604859c277)(p5, spec, zoomLevel);\n        world = new (0, $3aec07e3cb255787$export$812cd9544993280d)(spec, rng, ff);\n    };\n    p5.mouseClicked = ()=>{\n        const seed = (0, $1751a11947656e80$export$2e2bcd8739ae039)();\n        const rng = (0, $fc2b56482f704487$export$7c1be48efc5e4b3b)(seed);\n        const ff = new (0, $3e4f23251aebc465$export$b28d348bb9299663)((0, $3e4f23251aebc465$export$15b688b761fa49c2)(rng, spec));\n        world = new (0, $3aec07e3cb255787$export$812cd9544993280d)(spec, rng, ff);\n    };\n    p5.draw = ()=>{\n        world.render(rc);\n        world.step();\n    };\n}\nnew (0, (/*@__PURE__*/$parcel$interopDefault($ab4097e3648e46bf$exports)))($28c67c486a7b1e76$var$sketch);\n\n\n//# sourceMappingURL=index.fc468d73.js.map\n","import p5 from \"p5\";\n\nimport { World } from \"./world\";\nimport { Mote } from \"./mote\";\nimport { FlowField, flowSpec } from \"./flowField\";\nimport { Spec } from \"./spec\";\nimport randomSeed from \"./randomSeed\";\nimport { makeSeededRng } from \"./safeRandom\";\nimport { RenderContext } from \"./renderContext\";\n\nimport {\n  pi,\n  mod,\n  rescale,\n  clip,\n  sin,\n  cos,\n  dist,\n  distUpperBound,\n  distLowerBound,\n  angle,\n} from \"./safeMath\";\n\nfunction sketch(p5: p5) {\n  let R /*: Rng */;\n  let rc: RenderContext;\n  let spec: Spec;\n  let world: World;\n\n  const worldDim = 1000;\n\n  p5.setup = () => {\n    let seed = randomSeed();\n    console.log(`seed: ${seed}`);\n    const rng = makeSeededRng(seed);\n    const spec = new Spec();\n    const wh = p5.windowHeight;\n    const ww = p5.windowWidth;\n    if (ww > wh) {\n      spec.yDim = spec.xDim * (wh / ww);\n    } else {\n      spec.xDim = spec.yDim * (ww / wh);\n    }\n    const ff = new FlowField(flowSpec(rng, spec));\n    const zoomLevel = 1.1;\n    rc = new RenderContext(p5, spec, zoomLevel);\n    world = new World(spec, rng, ff);\n  };\n\n  p5.mouseClicked = () => {\n    const seed = randomSeed();\n    const rng = makeSeededRng(seed);\n    const ff = new FlowField(flowSpec(rng, spec));\n    world = new World(spec, rng, ff);\n  };\n\n  p5.draw = () => {\n    world.render(rc);\n    world.step();\n  };\n}\n\nnew p5(sketch);\n","module.exports=p5;","import p5 from \"p5\";\n\nimport { RenderContext } from \"./renderContext\";\nimport { Rng } from \"./safeRandom\";\nimport { FlowField } from \"./flowField\";\nimport { Mote } from \"./mote\";\nimport { Spec } from \"./spec\";\nimport { detectCollisions } from \"./collisions\";\n\nexport class World {\n  motes: Mote[];\n  spec: Spec;\n  rng: Rng;\n  flowField: FlowField;\n\n  constructor(spec: Spec, rng: Rng, flowField: FlowField) {\n    this.spec = spec;\n    this.motes = [];\n    this.rng = rng;\n    this.flowField = flowField;\n    while (this.motes.length < this.spec.numMotes) {\n      this.addMote();\n    }\n  }\n\n  randomPos(): p5.Vector {\n    const spec = this.spec;\n    return new p5.Vector(\n      this.rng.uniform(0, spec.xDim),\n      this.rng.uniform(0, spec.yDim)\n    );\n  }\n\n  inBounds(pos: p5.Vector) {\n    return (\n      pos.x >= 0 &&\n      pos.x <= this.spec.xDim &&\n      pos.y >= 0 &&\n      pos.y <= this.spec.yDim\n    );\n  }\n\n  // Adds a mote to the world\n  addMote() {\n    const mote = new Mote(this.randomPos(), this.spec.moteRadius);\n    this.motes.push(mote);\n  }\n\n  // Steps through one time unit in the simulation\n  step() {\n    while (this.motes.length < this.spec.numMotes) {\n      this.addMote();\n    }\n\n    const ff = this.flowField;\n    this.motes.forEach((mote) => mote.resetCollisions());\n    const collidingMotes = detectCollisions(\n      this.motes,\n      this.spec.moteInfluenceRadius,\n      this.spec.sectorSize,\n      Math.max(this.spec.xDim, this.spec.yDim)\n    );\n    for (const [mote1, mote2] of collidingMotes) {\n      const v = p5.Vector.sub(mote1.pos, mote2.pos);\n      const d = v.mag();\n      const boundaryDistance = d - mote1.radius - mote2.radius;\n      let forceFactor;\n      if (boundaryDistance < 0) {\n        forceFactor = 0.2;\n      } else {\n        forceFactor =\n          (0.2 * (this.spec.moteInfluenceRadius - boundaryDistance)) /\n          this.spec.moteInfluenceRadius;\n      }\n      v.setMag(forceFactor);\n      mote1.vCollide.add(v);\n      mote2.vCollide.sub(v);\n      mote1.nCollisions++;\n      mote2.nCollisions++;\n    }\n\n    this.motes.forEach((mote) => {\n      const vel = ff.flow(mote.pos);\n      mote.pos.add(vel);\n      mote.pos.add(mote.vCollide);\n    });\n\n    this.motes = this.motes.filter((mote) => this.inBounds(mote.pos));\n  }\n\n  render(rc: RenderContext) {\n    rc.background(240, 100, 10);\n    rc.strokeWeight(2);\n    rc.noFill();\n\n    this.motes.forEach((mote) => {\n      let hue = 30 + mote.nCollisions * 4;\n      rc.stroke(hue, 100, 40 + mote.nCollisions, 80);\n      rc.circle(mote.pos.x, mote.pos.y, mote.radius);\n    });\n  }\n}\n","import p5 from \"p5\";\nimport { RenderContext } from \"./renderContext\";\n\nexport class Mote {\n  pos: p5.Vector;\n  // aggregate collision force vector\n  vCollide: p5.Vector;\n  radius: number;\n  nCollisions = 0;\n\n  constructor(pos: p5.Vector, radius: number) {\n    this.pos = pos;\n    this.vCollide = new p5.Vector(0, 0);\n    this.radius = radius;\n  }\n\n  resetCollisions() {\n    this.vCollide = new p5.Vector(0, 0);\n    this.nCollisions = 0;\n  }\n}\n","import p5 from \"p5\";\n\nexport interface Collidable {\n  pos: p5.Vector;\n  radius: number;\n}\n\nfunction checkCollide(p1: p5.Vector, p2: p5.Vector, r: number) {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  return dx * dx + dy * dy < r * r;\n}\n\nexport function detectCollisions<T extends Collidable>(\n  motes: T[],\n  extraRadius: number,\n  sectorSize: number,\n  worldDim: number\n): T[][] {\n  if (\n    sectorSize <= 0 ||\n    worldDim <= 0 ||\n    sectorSize > worldDim ||\n    worldDim % sectorSize !== 0\n  ) {\n    throw new Error(\"invalid sector configuration\");\n  }\n  const results: T[][] = [];\n  const gridDimension = worldDim / sectorSize;\n  const sectors: T[][] = new Array(gridDimension * gridDimension)\n    .fill(null)\n    .map(() => []);\n  motes.forEach((mote) => {\n    if (mote.radius < 0 || !Number.isFinite(mote.radius)) {\n      throw new Error(\"Mote has invalid radius\");\n    }\n    const { pos, radius } = mote;\n    if (pos.x >= worldDim || pos.x < 0 || pos.y >= worldDim || pos.y < 0) {\n      throw new Error(\"Mote out of bounds\");\n    }\n    const i = Math.floor(mote.pos.x / sectorSize);\n    const j = Math.floor(mote.pos.y / sectorSize);\n\n    sectors[j * gridDimension + i].push(mote);\n  });\n  sectors.forEach((sector, index) => {\n    let adjacentIndices: number[] = [];\n    if (gridDimension === 1) {\n      adjacentIndices = [];\n    } else if (gridDimension === 2) {\n      adjacentIndices = [\n        index - gridDimension - 1, // top left\n        index - gridDimension, // top\n        index - 1, // left\n      ];\n    } else {\n      adjacentIndices = [\n        index - gridDimension - 1, // top left\n        index - gridDimension, // top\n        index - gridDimension + 1, // top right\n        index - 1, // left\n      ];\n    }\n\n    for (let i = 0; i < sector.length; i++) {\n      const mote1 = sector[i];\n\n      // Check for collisions within the current sector\n      for (let j = i + 1; j < sector.length; j++) {\n        const mote2 = sector[j];\n        if (\n          checkCollide(\n            mote1.pos,\n            mote2.pos,\n            mote1.radius + mote2.radius + extraRadius\n          )\n        ) {\n          results.push([mote1, mote2]);\n        }\n      }\n\n      // Check for collisions within adjacent sectors\n      adjacentIndices.forEach((adjacentIndex) => {\n        if (adjacentIndex >= 0 && adjacentIndex < sectors.length) {\n          const adjacentSector = sectors[adjacentIndex];\n          for (let j = 0; j < adjacentSector.length; j++) {\n            const mote2 = adjacentSector[j];\n            if (\n              checkCollide(\n                mote1.pos,\n                mote2.pos,\n                mote1.radius + mote2.radius + extraRadius\n              )\n            ) {\n              results.push([mote1, mote2]);\n            }\n          }\n        }\n      });\n    }\n  });\n  return results;\n}\n","import p5 from \"p5\";\nimport { dist, rescale, pi } from \"./safeMath\";\nimport { Rng } from \"./safeRandom\";\nimport { Spec } from \"./spec\";\n\ntype DisturbanceSpec = {\n  pos: p5.Vector;\n  theta: number;\n  radius: number;\n};\n\ntype FlowSpec = {\n  defaultTheta: number;\n  disturbances: DisturbanceSpec[];\n};\n\nexport function flowSpec(r: Rng, spec: Spec): FlowSpec {\n  const { numDisturbances, thetaVariance, defaultTheta } = spec;\n  const disturbances: DisturbanceSpec[] = [];\n  for (let i = 0; i < numDisturbances; i++) {\n    const disturbanceX = r.uniform(0, spec.xDim);\n    const disturbanceY = r.uniform(0, spec.yDim);\n    const disturbanceTheta = r.gauss(0, thetaVariance);\n    const disturbanceRadius = Math.abs(\n      r.gauss(spec.disturbanceRadiusMean, spec.disturbanceRadiusVariance)\n    );\n    disturbances.push({\n      pos: new p5.Vector(disturbanceX, disturbanceY),\n      theta: disturbanceTheta,\n      radius: disturbanceRadius,\n    });\n  }\n  return { defaultTheta, disturbances };\n}\n\nexport class FlowField {\n  // Hack - Flow field still thinks its a 1000x1000 grid\n  xMin = 0;\n  xMax = 1000;\n  yMin = 0;\n  yMax = 1000;\n  spacing = 10;\n  fieldPoints: number[][]; // Angle (theta) in a grid on the field\n\n  constructor(spec: FlowSpec) {\n    const iMax = (this.xMax - this.xMin) / this.spacing;\n    const jMax = (this.yMax - this.yMin) / this.spacing;\n    this.fieldPoints = Array.from({ length: iMax }, () =>\n      Array(jMax).fill(spec.defaultTheta)\n    );\n\n    for (const { pos, theta, radius } of spec.disturbances) {\n      const minX = pos.x - radius;\n      const maxX = pos.x + radius;\n      const minY = pos.y - radius;\n      const maxY = pos.y + radius;\n\n      const minI = Math.max(0, Math.floor(minX / this.spacing));\n      const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n      const minJ = Math.max(0, Math.floor(minY / this.spacing));\n      const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n\n      for (let i = minI; i < maxI; i++) {\n        const x = this.spacing * i;\n        for (let j = minJ; j < maxJ; j++) {\n          const y = this.spacing * j;\n          const d = dist(pos.x, pos.y, x, y);\n          const thetaAdjust = rescale(d, 0, radius, theta, 0);\n          this.fieldPoints[i][j] += thetaAdjust;\n        }\n      }\n    }\n  }\n\n  flow(pos: p5.Vector): p5.Vector {\n    const i = Math.floor(pos.x / this.spacing);\n    const j = Math.floor(pos.y / this.spacing);\n    const theta = this.fieldPoints[i][j];\n    return p5.Vector.fromAngle(theta);\n  }\n}\n","// Helpful math functions, adapted from safeMath.js in qql-art/frontend\n\nexport function pi(v: number): number {\n  return Math.PI * v;\n}\n\nexport function mod(n: number, m: number): number {\n  return ((n % m) + m) % m;\n}\n\nexport function snap(value: number, step: number): number {\n  return Math.round(value / step) * step;\n}\n\nexport function clip(\n  value: number,\n  min: number | null = null,\n  max: number | null = null\n) {\n  value = max !== null ? Math.min(value, max) : value;\n  value = min !== null ? Math.max(value, min) : value;\n  return value;\n}\n\nexport function rescale(\n  value: number,\n  oldMin: number,\n  oldMax: number,\n  newMin: number,\n  newMax: number\n) {\n  const clipped = clip(value, oldMin, oldMax);\n  const oldSpread = oldMax - oldMin;\n  const newSpread = newMax - newMin;\n  return newMin + (clipped - oldMin) * (newSpread / oldSpread);\n}\n\n// linear interpolation\nexport function lrp(start: number, end: number, t: number): number {\n  return start + (end - start) * t;\n}\n\nexport function average(...args: number[]): number {\n  return args.reduce((lhs, rhs) => lhs + rhs, 0) / args.length;\n}\n\nexport function sqrt(\n  value: number,\n  maxIterations = 1000,\n  epsilon = 1e-14,\n  target = 1e-7\n) {\n  if (value < 0) {\n    throw new Error(\"Value must be non-negative.\");\n  }\n\n  let guess = value;\n  for (let index = 0; index < maxIterations; index++) {\n    const error = guess * guess - value;\n    if (Math.abs(error) <= target) {\n      return guess;\n    }\n\n    const divisor = 2 * guess;\n    if (divisor <= epsilon) {\n      return guess;\n    }\n\n    guess -= error / divisor;\n  }\n\n  return guess;\n}\n\nexport function dist(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return sqrt(dx * dx + dy * dy);\n}\n\n// \"Fast\" atan2 implementation using a polynomial approximation.\n// Adapted from https://stackoverflow.com/questions/46210708.\nexport function atan2(y: number, x: number): number {\n  const ax = Math.abs(x);\n  const ay = Math.abs(y);\n  const mx = Math.max(ay, ax);\n  const mn = Math.min(ay, ax);\n  const a = mn / mx;\n  /* Minimax polynomial approximation to atan(a) on [0,1] */\n  const s = a * a;\n  const c = s * a;\n  const q = s * s;\n  let r = 0.024840285 * q + 0.18681418;\n  let t = -0.094097948 * q - 0.33213072;\n  r = r * s + t;\n  r = r * c + a;\n  /* Map to full circle */\n  if (ay > ax) r = 1.57079637 - r;\n  if (x < 0) r = 3.14159274 - r;\n  if (y < 0) r = -r;\n  return r;\n}\n\n// Build an interpolation-based lookup function from a given table.\n// The function is assumed period, so given values outside the range will wrap.\nfunction buildInterpolator(table: number[], min: number, max: number) {\n  return (value: number) => {\n    // Coerce value to [min, max) assuming periodicity.\n    value = mod(value - min, max - min) + min;\n\n    const rescaled = rescale(value, min, max, 0, table.length - 1);\n    const index = Math.floor(rescaled); // This is within [0, table.length - 1).\n    const fraction = rescaled - index; // This is within [0, 1).\n\n    // Function evaluated at value is within [start, end) based on index.\n    const start = table[index];\n    const end = table[index + 1];\n\n    // Interpolate within [start, end) using fractional part.\n    return lrp(start, end, fraction);\n  };\n}\n\nconst cosTable = [\n  1.0, 0.99179, 0.96729, 0.92692, 0.87132, 0.80141, 0.71835, 0.62349, 0.51839,\n  0.40478, 0.28453, 0.1596, 0.03205, -0.09602, -0.22252, -0.34537, -0.46254,\n  -0.57212, -0.6723, -0.76145, -0.83809, -0.90097, -0.94906, -0.98156, -0.99795,\n  -0.99795, -0.98156, -0.94906, -0.90097, -0.83809, -0.76145, -0.6723, -0.57212,\n  -0.46254, -0.34537, -0.22252, -0.09602, 0.03205, 0.1596, 0.28453, 0.40478,\n  0.51839, 0.62349, 0.71835, 0.80141, 0.87132, 0.92692, 0.96729, 0.99179, 1.0,\n];\n\nexport const cos = buildInterpolator(cosTable, 0, 2 * Math.PI);\n\nconst sinTable = [\n  0.0, 0.12788, 0.25365, 0.37527, 0.49072, 0.59811, 0.69568, 0.78183, 0.85514,\n  0.91441, 0.95867, 0.98718, 0.99949, 0.99538, 0.97493, 0.93847, 0.8866,\n  0.82017, 0.74028, 0.64823, 0.54553, 0.43388, 0.31511, 0.19116, 0.06407,\n  -0.06407, -0.19116, -0.31511, -0.43388, -0.54553, -0.64823, -0.74028,\n  -0.82017, -0.8866, -0.93847, -0.97493, -0.99538, -0.99949, -0.98718, -0.95867,\n  -0.91441, -0.85514, -0.78183, -0.69568, -0.59811, -0.49072, -0.37527,\n  -0.25365, -0.12788, -0.0,\n];\n\nexport const sin = buildInterpolator(sinTable, 0, 2 * Math.PI);\n\nexport function angle(x1: number, y1: number, x2: number, y2: number): number {\n  const a = atan2(y2 - y1, x2 - x1);\n  return mod(a, pi(2.0));\n}\n\n// Fast upper bound of `dist()` function.\nexport function distUpperBound(x1: number, y1: number, x2: number, y2: number) {\n  const dx = Math.abs(x1 - x2);\n  const dy = Math.abs(y1 - y2);\n\n  const min = Math.min(dx, dy);\n  const max = Math.max(dx, dy);\n\n  const alpha = 1007 / 1110;\n  const beta = 441 / 1110;\n\n  return alpha * max + beta * min;\n}\n\n// Fast lower bound of `dist()` function.\nexport function distLowerBound(x1: number, y1: number, x2: number, y2: number) {\n  const dx = Math.abs(x1 - x2);\n  const dy = Math.abs(y1 - y2);\n\n  const min = Math.min(dx, dy);\n  const max = Math.max(dx, dy);\n\n  const beta = 441 / 1024;\n\n  return max + beta * min;\n}\n\nexport function addPolarOffset(\n  x: number,\n  y: number,\n  theta: number,\n  magnitude: number\n): number[] {\n  return [x + magnitude * cos(theta), y + magnitude * sin(theta)];\n}\n","export class Spec {\n  numMotes = 6000;\n  // Dimensions overwritten at p5 setup time,\n  // one will get reduced to match window ratio\n  xDim = 1000;\n  yDim = 1000;\n  moteRadius = 8;\n  moteInfluenceRadius = 8;\n  moteRenderScaling = 0.3;\n  sectorSize = 40;\n\n  // Flow field settings\n  numDisturbances = 30;\n  thetaVariance = 3.14;\n  defaultTheta = 0;\n  disturbanceRadiusMean = 100;\n  disturbanceRadiusVariance = 200;\n}\n","// picks a uniformly random `bytes32` using JS Math.random state\n// (i.e., not itself seeded by `safe-random.js`)\nexport default function randomSeed(): string {\n  let nibbles = Array(64)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * 16).toString(16));\n  return \"0x\" + nibbles.join(\"\");\n}\n","import randomSeed from \"./randomSeed\";\n\n// Note that the index order [0, 1, 2, 3] is little-endian\nconst eps = Math.pow(2, -32),\n  m0 = 0x7f2d,\n  m1 = 0x4c95,\n  m2 = 0xf42d,\n  m3 = 0x5851, // 6364136223846793005\n  a0 = 0x814f,\n  a1 = 0xf767,\n  a2 = 0x7b7e,\n  a3 = 0x1405; // 1442695040888963407\n\nexport function makeSeededRng(hash: string /*: bytes32 */) /*: Rng */ {\n  const rng = new Rng();\n  rng.setSeed(hash);\n  return rng;\n}\n\nexport function makeUnseededRng() /*: Rng */ {\n  return makeSeededRng(randomSeed());\n}\n\nexport class Rng {\n  _state: Uint16Array;\n  _dv: DataView;\n  _nG: number | null;\n  _hNG: boolean;\n\n  constructor() {\n    this._state = new Uint16Array(4);\n    this._dv = new DataView(this._state.buffer);\n    this._nG = null; // nextGaussian\n    this._hNG = false; // hasNextGaussian\n  }\n\n  // sets the seed to a tokenData hash string \"0x...\"\n  setSeed(hash: string) {\n    this._hNG = false;\n    this._nG = null;\n    const nBytes = ~~((hash.length - 2) / 2);\n    const bytes: number[] = [];\n    for (let j = 0; j < nBytes; j++) {\n      const e0 = 2 + 2 * j;\n      bytes.push(parseInt(hash.slice(e0, e0 + 2), 16));\n    }\n\n    // to keep it simple, we just use 32bit murmur2 with two different seeds\n    const seed_a = 1690382925;\n    const seed_b = 72970470;\n    const lower = hash32(bytes, seed_a);\n    const upper = hash32(bytes, seed_b);\n    this._dv.setUint32(0, lower);\n    this._dv.setUint32(4, upper);\n  }\n\n  // random value between 0..1\n  rnd() {\n    const state = this._state;\n    // Advance internal state\n    const s0 = state[0],\n      s1 = state[1],\n      s2 = state[2],\n      s3 = state[3],\n      new0 = (a0 + m0 * s0) | 0,\n      new1 = (a1 + m0 * s1 + (m1 * s0 + (new0 >>> 16))) | 0,\n      new2 = (a2 + m0 * s2 + m1 * s1 + (m2 * s0 + (new1 >>> 16))) | 0,\n      new3 = a3 + m0 * s3 + (m1 * s2 + m2 * s1) + (m3 * s0 + (new2 >>> 16));\n    (state[0] = new0), (state[1] = new1), (state[2] = new2);\n    state[3] = new3;\n\n    // Calculate output function (XSH RR), uses old state\n    const xorshifted =\n        (s3 << 21) + (((s3 >> 2) ^ s2) << 5) + (((s2 >> 2) ^ s1) >> 11),\n      out_int32 =\n        (xorshifted >>> (s3 >> 11)) | (xorshifted << (-(s3 >> 11) & 31));\n    return eps * (out_int32 >>> 0);\n  }\n\n  // random value between min (inclusive) and max (exclusive)\n  uniform(min = 1, max: number | null = null) {\n    if (max === null) {\n      [min, max] = [0, min];\n    }\n    return this.rnd() * (max - min) + min;\n  }\n\n  // random gaussian distribution\n  gauss(mean = 0, variance = 1) {\n    // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/Random.java#L496\n    if (this._hNG) {\n      this._hNG = false;\n      var result = this._nG as number;\n      this._nG = null;\n      return mean + variance * result;\n    } else {\n      var v1 = 0;\n      var v2 = 0;\n      var s = 0;\n      do {\n        v1 = this.rnd() * 2 - 1; // between -1 and 1\n        v2 = this.rnd() * 2 - 1; // between -1 and 1\n        s = v1 * v1 + v2 * v2;\n      } while (s >= 1 || s === 0);\n      var multiplier = Math.sqrt((-2 * Math.log(s)) / s);\n      this._nG = v2 * multiplier;\n      this._hNG = true;\n      return mean + variance * (v1 * multiplier);\n    }\n  }\n\n  odds(p: number) {\n    return this.uniform() <= p;\n  }\n\n  choice<T>(items: T[]): T {\n    return items[Math.floor(this.uniform(0, items.length))];\n  }\n\n  weightedChoice<T>(items: [T, number][]) {\n    const sumWeight = items\n      .map(([, weight]) => weight)\n      .reduce((lhs, rhs) => lhs + rhs, 0);\n    const bisection = sumWeight * this.uniform();\n\n    let cumWeight = 0;\n    for (let index = 0; index < items.length; index++) {\n      const [value, weight] = items[index];\n      cumWeight += weight;\n      if (cumWeight >= bisection) {\n        return value;\n      }\n    }\n\n    const [lastValue] = items[items.length - 1];\n    return lastValue;\n  }\n\n  // alias for weightedChoice\n  wc<T>(items: [T, number][]) {\n    return this.weightedChoice(items);\n  }\n\n  // a version of shuffle that safely uses our PRNG\n  shuffle<T>(items: T[]): T[] {\n    const joined: [number, T][] = items.map((item) => [\n      this.uniform(0.0, 1.0),\n      item,\n    ]);\n\n    joined.sort((a, b) => {\n      return a[0] < b[0] ? -1 : 1;\n    });\n\n    return joined.map(([, item]) => item);\n  }\n\n  // returns a copy of the array that has been \"winnowed\" down to contain at most `num`\n  // entries, while preserving the original order\n  winnow<T>(input: T[], num: number): T[] {\n    const items = input.slice();\n    while (items.length > num) {\n      const index = Math.floor(this.rnd() * items.length);\n      items.splice(index, 1);\n    }\n    return items;\n  }\n}\n\n// internally gets a 32-bit from tokenData hash bytes\nfunction hash32(bytes: number[], seed = 0) {\n  // murmur2 32bit\n  // https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\n  const K = 16;\n  const mask = 65535;\n  const maskByte = 0xff;\n  var m = 0x5bd1e995;\n  var l = bytes.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  while (l >= 4) {\n    k =\n      (bytes[i] & maskByte) |\n      ((bytes[++i] & maskByte) << 8) |\n      ((bytes[++i] & maskByte) << 16) |\n      ((bytes[++i] & maskByte) << 24);\n    k = (k & mask) * m + ((((k >>> K) * m) & mask) << K);\n    k ^= k >>> 24;\n    k = (k & mask) * m + ((((k >>> K) * m) & mask) << K);\n    h = ((h & mask) * m + ((((h >>> K) * m) & mask) << K)) ^ k;\n    l -= 4;\n    ++i;\n  }\n  /* eslint-disable no-fallthrough */\n  switch (l) {\n    case 3:\n      h ^= (bytes[i + 2] & maskByte) << K;\n    case 2:\n      h ^= (bytes[i + 1] & maskByte) << 8;\n    case 1:\n      h ^= bytes[i] & maskByte;\n      h = (h & mask) * m + ((((h >>> K) * m) & mask) << K);\n  }\n  /* eslint-enable no-fallthrough */\n  h ^= h >>> 13;\n  h = (h & mask) * m + ((((h >>> K) * m) & mask) << K);\n  h ^= h >>> 15;\n  return h >>> 0;\n}\n","import p5 from \"p5\";\nimport { Spec } from \"./spec\";\n\nexport class RenderContext {\n  p5: p5;\n\n  spec: Spec;\n\n  r: number;\n  c: p5.Renderer;\n\n  // Ratio of how zoomed in we are. 1.1x zoom implies we are dropping\n  // off the edges of the simulation to not render them.\n  // We keep the center of the sim on the center of the screen (for now)\n  zoom: number;\n  // X-center of the zoomed viewport\n  zoomX: number;\n  // Y-center of the zoomed viewport\n  zoomY: number;\n\n  constructor(p5: p5, spec: Spec, zoom: number) {\n    this.p5 = p5;\n    this.spec = spec;\n    this.r = p5.windowWidth / spec.xDim;\n    this.zoom = zoom;\n    this.zoomX = spec.xDim / 2;\n    this.zoomY = spec.yDim / 2;\n    p5.pixelDensity(1);\n    p5.colorMode(p5.HSB, 360, 100, 100, 100);\n\n    this.c = p5.createCanvas(p5.windowWidth, p5.windowHeight);\n  }\n\n  background(h: number, s: number, b: number) {\n    this.p5.background(h, s, b);\n  }\n\n  stroke(h: number, s: number, b: number, a: number) {\n    this.p5.stroke(h, s, b, a);\n  }\n\n  noStroke() {\n    this.p5.noStroke();\n  }\n\n  circle(x: number, y: number, r: number) {\n    const px = (x - this.zoomX) * this.zoom * this.r + this.p5.windowWidth / 2;\n    const py = (y - this.zoomY) * this.zoom * this.r + this.p5.windowHeight / 2;\n    // underlying api uses diameter not radius, converted here.\n    this.p5.circle(\n      px,\n      py,\n      2 * r * this.r * this.zoom * this.spec.moteRenderScaling\n    );\n  }\n\n  noFill() {\n    this.p5.noFill();\n  }\n\n  strokeWeight(w: number) {\n    this.p5.strokeWeight(w);\n  }\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$ab4097e3648e46bf$exports","p5","$5fee48862b0a2a9b$export$c63751cf8691a0b8","constructor","pos","radius","nCollisions","vCollide","Vector","resetCollisions","$853c9283513b3b8b$var$checkCollide","p1","p2","r","dx","x","dy","y","$3aec07e3cb255787$export$812cd9544993280d","spec","rng","flowField","motes","length","numMotes","addMote","randomPos","uniform","xDim","yDim","inBounds","mote","moteRadius","push","step","ff","mote1","mote2","forEach","extraRadius","sectorSize","worldDim","Error","results","gridDimension","sectors","Array","fill","map","Number","isFinite","i","Math","floor","j","sector","index","adjacentIndices","adjacentIndex","adjacentSector","moteInfluenceRadius","max","forceFactor","v","sub","boundaryDistance","d","mag","setMag","add","vel","flow","filter","render","rc","background","strokeWeight","noFill","hue","stroke","circle","$0e2c58cfdfdc3132$export$bd2782c820638828","value","oldMin","oldMax","newMin","newMax","clipped","$0e2c58cfdfdc3132$export$e0b576e7a74416cd","min","$0e2c58cfdfdc3132$var$buildInterpolator","table","m","rescaled","$0e2c58cfdfdc3132$export$842a2cf37af977e1","n","start","end","$3e4f23251aebc465$export$15b688b761fa49c2","numDisturbances","thetaVariance","defaultTheta","disturbances","disturbanceX","disturbanceY","disturbanceTheta","gauss","disturbanceRadius","abs","disturbanceRadiusMean","disturbanceRadiusVariance","theta","PI","$3e4f23251aebc465$export$b28d348bb9299663","xMin","xMax","yMin","yMax","spacing","iMax","jMax","fieldPoints","from","minX","maxX","minY","maxY","minI","maxI","ceil","minJ","maxJ","thetaAdjust","x1","y1","x2","y2","$0e2c58cfdfdc3132$export$eba8049fb5020b81","maxIterations","epsilon","target","guess","error","divisor","fromAngle","$791c32fb268f4933$export$6298b650a59e6ea5","moteRenderScaling","$1751a11947656e80$export$2e2bcd8739ae039","nibbles","random","toString","join","$fc2b56482f704487$export$7c1be48efc5e4b3b","hash","$fc2b56482f704487$export$b15cd8f5723f9e05","setSeed","_state","Uint16Array","_dv","DataView","buffer","_nG","_hNG","nBytes","bytes","e0","parseInt","slice","lower","$fc2b56482f704487$var$hash32","upper","setUint32","rnd","state","s0","s1","s2","s3","new0","$fc2b56482f704487$var$a0","$fc2b56482f704487$var$m0","new1","$fc2b56482f704487$var$a1","$fc2b56482f704487$var$m1","new2","$fc2b56482f704487$var$a2","$fc2b56482f704487$var$m2","new3","$fc2b56482f704487$var$a3","$fc2b56482f704487$var$m3","xorshifted","$fc2b56482f704487$var$eps","out_int32","mean","variance","result","v1","v2","s","multiplier","sqrt","log","odds","p","choice","items","weightedChoice","bisection","sumWeight","weight","reduce","lhs","rhs","cumWeight","lastValue","wc","shuffle","joined","item","sort","b","winnow","input","num","splice","seed","k","l","h","K","$f9aa35ed4b7c36bf$export$21d659604859c277","zoom","windowWidth","zoomX","zoomY","pixelDensity","colorMode","HSB","c","createCanvas","windowHeight","noStroke","px","py","w","world","setup","console","wh","ww","mouseClicked","draw"],"version":3,"file":"index.fc468d73.js.map"}